/**********************************************************
 * This file is generated by 20-sim ANSI-C Code Generator
 *
 *  file:  xxmodel.c
 *  model: PositionControllerPan
 *  expmt: Jiwy
 *  date:  June 2, 2021
 *  time:  12:30:12 PM
 *  user:  20-sim 4.8 Campus License
 *  from:  Universiteit Twente
 *  build: 4.8.3.10415
 **********************************************************/

/* This file contains the actual model variables and equations */

/* Note: Alias variables are the result of full optimization
   of the model in 20-sim. As a result, only the real variables
   are used in the model for speed. The user may also include
   the alias variables by adding them to the end of the array:

   XXDouble xx_variables[NUMBER_VARIABLES + NUMBER_ALIAS_VARIABLES + 1];
   XXString xx_variable_names[] = {
     VARIABLE_NAMES, ALIAS_VARIABLE_NAMES, NULL
   };

   and calculate them directly after the output equations:

   void XXCalculateOutput (void)
   {
     OUTPUT_EQUATIONS
     ALIAS_EQUATIONS
   }
*/

/* system include files */
#include <stdlib.h>
#include <math.h>
#include <string.h>

/* 20-sim include files */
#include "panmodel.h"

/* the global variables */
XXDouble xx_start_time = 0.0;
XXDouble xx_finish_time = 20.0;
XXDouble xx_step_size = 0.01;
XXDouble xx_time = 0.0;
XXInteger xx_steps = 0;
XXBoolean xx_initialize = XXTRUE;
XXBoolean xx_major = XXTRUE;
XXBoolean xx_stop_simulation = XXFALSE;

/* the variable arrays */
XXDouble xx_P[xx_parameters_size][motor_instances];		/* parameters */
XXDouble xx_I[xx_initialvalues_size][motor_instances];		/* initial values */
XXDouble xx_V[xx_variables_size][motor_instances];		/* variables */
XXDouble xx_s[xx_states_size][motor_instances];		/* states */
XXDouble xx_R[xx_states_size][motor_instances];		/* rates (or new states) */


#if (7 > 8192) && defined _MSC_VER
#pragma optimize("", off)
#endif
void initialize_pan(void)
{
	xx_P[0][0] = 0.0;		/* corrGain\K */
	xx_P[1][0] = 2.6;		/* PID1\kp */
	xx_P[2][0] = 0.05;		/* PID1\tauD */
	xx_P[3][0] = 0.17;		/* PID1\beta */
	xx_P[4][0] = 9.0;		/* PID1\tauI */
	xx_P[5][0] = -0.99;		/* SignalLimiter2\minimum */
	xx_P[6][0] = 0.99;		/* SignalLimiter2\maximum */
}

void initialize_tilt(void)
{
	/* Change these values! */
	xx_P[0][1] = 0.0;		/* corrGain\K */
	xx_P[1][1] = 1.6;		/* PID1\kp */
	xx_P[2][1] = 0.05;		/* PID1\tauD */
	xx_P[3][1] = 0.001;		/* PID1\beta */
	xx_P[4][1] = 10.50;		/* PID1\tauI */
	xx_P[5][1] = -0.99;		/* SignalLimiter2\minimum */
	xx_P[6][1] = 0.99;		/* SignalLimiter2\maximum */
}


void XXModelInitialize_parameters(void)
{
	initialize_pan();
	initialize_tilt();
}
#if (7 > 8192) && defined _MSC_VER
#pragma optimize("", on)
#endif

void XXModelInitialize_initialvalues(void)
{
	/* set the initial values */
	for (int index = 0; index < motor_instances; index++) {
	xx_I[0][index] = 0.0;		/* PID1\uD_previous_initial */
	xx_I[1][index] = 0.0;		/* PID1\error_previous_initial */
	xx_I[2][index] = 0.0;		/* PID1\uI_previous_initial */
}
}

void XXModelInitialize_states(void)
{
	/* set the states */
	for (int index = 0; index < motor_instances; index++) {
		xx_s[0][index] = xx_I[0][index];		/* PID1\uD_previous */
		xx_s[1][index] = xx_I[1][index];		/* PID1\error_previous */
		xx_s[2][index] = xx_I[2][index];		/* PID1\uI_previous */
	}
}

void XXModelInitialize_variables(void)
{
	/* initialize the variable memory to zero */
	memset(xx_V, 0, xx_variables_size*motor_instances * sizeof(XXDouble));
}

/* this method is called before calculation is possible */
void XXModelInitialize (void)
{
	XXModelInitialize_parameters();
	XXModelInitialize_variables();
	XXModelInitialize_initialvalues();
	XXModelInitialize_states();
}

/* This function calculates the dynamic equations of the model.
 * These equations are called from the integration method
 * to calculate the new model rates (that are then integrated).
 */
void XXCalculateDynamic (void)
{
	for (int index = 0; index < motor_instances; index++) {
		/* PID1\factor = 1 / (sampletime + PID1\tauD * PID1\beta); */
		xx_V[2][index] = 1.0 / (xx_step_size + xx_P[2][index] * xx_P[3][index]);

		/* PlusMinus1\plus1 = in; */
		xx_V[3][index] = xx_V[7][index];

		/* Splitter1\input = position; */
		xx_V[5][index] = xx_V[8][index];

		/* corrGain\corr = corrGain\K * Splitter1\input; */
		xx_V[0][index] = xx_P[0][index] * xx_V[5][index];

		/* PID1\error = PlusMinus1\plus1 - Splitter1\input; */
		xx_R[1][index] = xx_V[3][index] - xx_V[5][index];

		/* PID1\uD = PID1\factor * (((PID1\tauD * PID1\uD_previous) * PID1\beta + (PID1\tauD * PID1\kp) * (PID1\error - PID1\error_previous)) + (sampletime * PID1\kp) * PID1\error); */
		xx_R[0][index] = xx_V[2][index] * (((xx_P[2][index] * xx_s[0][index]) * xx_P[3][index] + (xx_P[2][index] * xx_P[1][index]) * (xx_R[1][index] - xx_s[1][index])) + (xx_step_size * xx_P[1][index]) * xx_R[1][index]);

		/* PID1\uI = PID1\uI_previous + (sampletime * PID1\uD) / PID1\tauI; */
		xx_R[2][index] = xx_s[2][index] + (xx_step_size * xx_R[0][index]) / xx_P[4][index];

		/* PID1\output = PID1\uI + PID1\uD; */
		xx_V[1][index] = xx_R[2][index] + xx_R[0][index];

		/* SignalLimiter2\output = (if PID1\output < SignalLimiter2\minimum then SignalLimiter2\minimum else (if PID1\output > SignalLimiter2\maximum then SignalLimiter2\maximum else PID1\output end) end); */
		xx_V[4][index] = ((xx_V[1][index] < xx_P[5][index]) ?
			/* SignalLimiter2\minimum */
			xx_P[5][index]
			:
			/* (if PID1\output > SignalLimiter2\maximum then SignalLimiter2\maximum else PID1\output end) */
			((xx_V[1][index] > xx_P[6][index]) ?
				/* SignalLimiter2\maximum */
				xx_P[6][index]
				:
				/* PID1\output */
				xx_V[1][index]
				)
			);

	}
	/* increment the step counter */
	xx_steps++;
}

/* This function calculates the output equations of the model.
 * These equations are not needed for calculation of the rates
 * and are kept separate to make the dynamic set of equations smaller.
 * These dynamic equations are called often more than one time for each
 * integration step that is taken. This makes model computation much faster.
 */
void XXCalculateOutput (void)
{
	for (int index = 0; index < motor_instances; index++) {
		/* corr = corrGain\corr; */
		xx_V[6][index] = xx_V[0][index];

		/* out = SignalLimiter2\output; */
		xx_V[9][index] = xx_V[4][index];
	}
}
