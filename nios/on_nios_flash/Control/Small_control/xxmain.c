/**********************************************************
 * This file is generated by 20-sim ANSI-C Code Generator
 *
 *  file:  xxmain.c
 *  subm:  PositionControllerPan
 *  model: PositionControllerPan
 *  expmt: Jiwy
 *  date:  June 2, 2021
 *  time:  12:30:12 PM
 *  user:  20-sim 4.8 Campus License
 *  from:  Universiteit Twente
 *  build: 4.8.3.10415
 **********************************************************/

/* This file is a demo application of how the submodel function can 
 * be used. It uses the global time variables that are used by both
 * the submodel and the integration method.
 *
 * PLEASE NOTE: THIS IS AN EXAMPLE WHERE ALL INPUTS ARE ZERO ! 
 * USE YOUR OWN INPUTS INSTEAD!! ALSO THE SUBMODEL MIGHT SIMPLY 
 * NOT WORK CORRECTLY WITH INPUTS THAT ARE ZERO.
 */

/* 20-sim include files */
#include "pansubmod.h"
#include "xxmain.h"
#include "stdio.h"
#include <time.h>

#define PWM_dutycycle_resolution 1000
#define Pan_encoder_resolution 1000
#define Tilt_encoder_resolution 1000

#define PI 3.1415927

#define Pan_max 1
#define Tilt_max 1


/* The main function */

//XXDouble tilt_xx_P[7];



int main()
{
	int looptime = 100000000;
	long ctr = 0;
	long ctr_1 = 0;

	//first define parameters. 
	XXDouble u [2 + 1 + 2];
	XXDouble p_u [2 + 1 + 2];
	XXDouble y [2 + 1 + 2];

	//define home position
	XXDouble home_u[2] = { 0 };
	/*\
	* Pan:
	*	u[0]: Setpoint
	*	u[1]: Position
	*	y[0]: Correction
	*	y[1]: Steer / output
	* 
	* Tilt:
	*	u[2]: Setpoint
	*	u[3]: Position
	*	y[2]: Correction
	*	y[3]: Steer / output
	*/

	/* Initialize the inputs and outputs with correct initial values */
	for (int index = 0; index < motor_instances; index++) {
	u[0 + motor_instances * index] = 0.0;		/* in */
	u[1 + motor_instances * index] = 0.0;		/* position */

	y[0 + motor_instances * index] = 0.0;		/* corr */
	y[1 + motor_instances * index] = 0.0;		/* out */
	}

	//set Previous u to equal u
	for (int index = 0; index < sizeof(u); index++) p_u[index] = u[index];

	/* Initialize the submodel itself */
	XXInitializeSubmodel (u, y, xx_time);

	//Here we want to do some homing of some sort
	home_motors();

	/*Ultimately bind a timer interrupt to the updating of the model*/
		//alt_ic_isr_register(TIMER_IRQ_INTERRUPT_CONTROLLER_ID, TIMER_IRQ, updateControl, context, 0);
	// alternatively FreeRTOS would be a good use


	/* Simple loop, the time is incremented by the integration method */
	//while ( (xx_time < xx_finish_time) && (xx_stop_simulation == XXFALSE) )
	clock_t t = clock();
	while (1)
	{
		/* Call the submodel to calculate the output */
		
		/* The MAIN Loop*/

		
		//retrieve setpoints
		//res = mRad = Rad * 10^-3
		//u[0] = u[1] + double(IORD(PIO_PANSET_BASE, 0x00))/1000 + PI;
		//u[2] = u[3] + double(IORD(PIO_TILTSET_BASE, 0x00))/1000 + PI;



		//getPositions(u);
		//updateControl(u, y, xx_time);






		if (ctr - ctr_1 > looptime) {
			
			if (u[3] < 2) u[3] = u[3] += 0.1;
			float out = y[3];
			float pos = u[3];
			printf("Position = %f, pwm sig = %f \n", pos, out);
			getPositions(u, home_u);
			updateControl(p_u, u, y, xx_time, home_u);
			ctr_1 = ctr;
			printf("waiting took %d ticks \n", (clock()-t));
			t = clock();
		}

		ctr++;
		if (ctr < 0) return 0;
	}

	/* Perform the final calculations */
	XXTerminateSubmodel (u, y, xx_time);

	/* and we are done */
	return 0;
}

void home_motors(void) {
	//should work same as safety layer
	_Bool not_home = 1;
	while (not_home) {

	}
	//push reset to encoders or save state and start counting
}

void updateControl(XXDouble *pu, XXDouble *u, XXDouble *y, XXDouble t, XXDouble *home_u) {
	if (u[0] > Pan_max) u[0] = Pan_max;
	if (u[2] > Tilt_max) u[2] = Tilt_max;

	//need some safety layer around this!
	int breakp[2] = { 1 };
	for (int index = 0; index < motor_instances; index++) {
		if (y[1 + motor_instances * index] != 0 && pu[1 + motor_instances * index] == u[1 + motor_instances * index]) {
			breakp[index] = 0;
			if (y[1 + motor_instances * index] < 0) home_u[index] = u[1 + motor_instances * index];
			//Set the home position
		}
	}

	for (int index = 0; index < sizeof(u); index++) pu[index] = u[index];


	XXCalculateSubmodel(u, y, t);
	//set pwm values
	for (int index = 0; index < motor_instances; index++) {
		int duty_cycle = 0;
		double out = y[1 + motor_instances * index];
		if (out == 0) {
			// set movement and direction registers to brake/off
			IOWR(BASE, 0x00, duty_cycle);
		}else if(out < 0) {
			duty_cycle = breakp[index]*-1 * out * PWM_dutycycle_resolution;
			IOWR(BASE, 0x00, duty_cycle);
			// set movement to left
			IOWR(BASE, 0x ?, 1 );
		}else {
			duty_cycle = breakp[index] * out * PWM_dutycycle_resolution;
			IOWR(BASE, 0x00, duty_cycle);
			//set movement register to right
			IOWR(BASE, 0x ?, 0 );
		}
	}

}

void getPositions(XXDouble* u, XXDouble* hu) {
	//pan
	u[1] = IORD(BASE, 0x14)/Pan_encoder_resolution-hu[0];

	//tilt
	u[3] = IORD(BASE2, 0x14)/Tilt_encoder_resolution-hu[1];
}
